package main

import (
	"bufio"
	"bytes"
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"regexp"

	//  "log"
	//  "net"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"

	//  "strings"
	"log"
	"strings"

	_ "github.com/lib/pq" // PostgreSQL driver
	"github.com/miekg/dns"
)

// Vulnerable services for subdomain takeovers and their associated fingerprints
var vulnerableServices = map[string]string{
	"elasticbeanstalk.com": "NXDOMAIN",
	"s3.amazonaws.com":     "The specified bucket does not exist",
	"agilecrm.com":         "Sorry, this page is no longer available.",
	"airee.ru":             "Ошибка 402. Сервис Айри.рф не оплачен",
	"animaapp.io":          "The page you were looking for does not exist.",
	"bitbucket.io":         "Repository not found",
	"canny.io":             "Company Not Found There is no such company. Did you enter the right URL?",
	"cargo.site":           "404 Not Found",
	"digitalocean.com":     "Domain uses DO name servers with no records in DO.",
	"trydiscourse.com":     "NXDOMAIN",
	"furyns.com":           "404: This page could not be found.",
	"getresponse.com":      "With GetResponse Landing Pages, lead generation has never been easier",
	"ghost.io":             "Site unavailable\\.|Failed to resolve DNS path for this host",
	"github.io":            "There isn't a GitHub Pages site here.",
	"hatenablog.com":       "404 Blog is not found",
	"helpjuice.com":        "We could not find what you're looking for.",
	"helpscoutdocs.com":    "No settings were found for this company:",
	"helprace.com":         "HTTP_STATUS=301",
	"heroku.com":           "No such app",
	"youtrack.cloud":       "is not a registered InCloud YouTrack",
	"launchrock.com":       "HTTP_STATUS=500",
	"ngrok.io":             "Tunnel .*\\.ngrok.io not found",
	"pantheon.io":          "404 error unknown site!",
	"pingdom.com":          "Sorry, couldn't find the status page",
	"readme.io":            "The creators of this project are still working on making everything perfect!",
	"readthedocs.org":      "The link you have followed or the URL that you entered does not exist.",
	"short.io":             "Link does not exist",
	"52.16.160.97":         "This job board website is either expired or its domain name is invalid.",
	"strikinglydns.com":    "PAGE NOT FOUND.",
	"na-west1.surge.sh":    "project not found",
	"surveysparrow.com":    "Account not found.",
	"read.uberflip.com":    "The URL you've accessed does not provide a hub.",
	"uptimerobot.com":      "page not found",
	"wordpress.com":        "Do you want to register .*.wordpress.com?",
	"worksites.net":        "Hello! Sorry, but the website you’re looking for doesn’t exist.",

	// Added Azure Services (All check for NXDOMAIN)
	"cloudapp.net":            "NXDOMAIN",
	"cloudapp.azure.com":      "NXDOMAIN",
	"azurewebsites.net":       "NXDOMAIN",
	"blob.core.windows.net":   "NXDOMAIN",
	"azure-api.net":           "NXDOMAIN",
	"azurehdinsight.net":      "NXDOMAIN",
	"azureedge.net":           "NXDOMAIN",
	"azurecontainer.io":       "NXDOMAIN",
	"database.windows.net":    "NXDOMAIN",
	"azuredatalakestore.net":  "NXDOMAIN",
	"search.windows.net":      "NXDOMAIN",
	"azurecr.io":              "NXDOMAIN",
	"redis.cache.windows.net": "NXDOMAIN",
	"servicebus.windows.net":  "NXDOMAIN",
	"visualstudio.com":        "NXDOMAIN",
}

// Database connection settings
const (
	host     = "68.183.45.202"
	port     = 5432
	user     = "subdomain_user"
	password = "Bugcrowd123!Bugcrowd123!"
	dbname   = "subdomain_monitor"
)

// Discord webhooks
const (
	scanCompletionWebhook    = "https://discord.com/api/webhooks/1259155015734661160/PpI7ZvU1cloUChlT0IaqrpnSUq-r9jJaD4HwCJFc4wtWGD26VCCgl9L3GXecvq6JWkbp"
	potentialTakeoverWebhook = "https://discord.com/api/webhooks/1285159259369373727/14W91iNuRunG8xpVCbx7dRAO3k7GYJ3Fz3TkqVQ2hCI0hA1QxG_50UVbD2G9Ttm0JkpD"
)

// Helper function to send a notification to Discord
func sendDiscordNotification(webhookURL, message string) error {
	payload := map[string]string{"content": message}
	jsonData, err := json.Marshal(payload)
	if err != nil {
		return fmt.Errorf("failed to marshal payload: %v", err)
	}

	resp, err := http.Post(webhookURL, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return fmt.Errorf("failed to send POST request: %v", err)
	}
	defer resp.Body.Close()

	// Now using io.ReadAll to read response body instead of os.ReadFile
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read response body: %v", err)
	}

	if resp.StatusCode != http.StatusNoContent {
		return fmt.Errorf("unexpected response from Discord: %s", body)
	}

	return nil
}

// insertOrUpdateSubdomain inserts or updates a subdomain in the database
func insertOrUpdateSubdomain(db *sql.DB, subdomain, status, cname string, hasIP, vulnerable bool) error {
	query := `
    INSERT INTO subdomains (name, status, cname, has_ip, last_checked, status_changed, vulnerable)
    VALUES ($1, $2, $3, $4, NOW(), TRUE, $5)
    ON CONFLICT (name)
    DO UPDATE SET 
        status = $2, 
        cname = $3, 
        has_ip = $4, 
        last_checked = NOW(),
        status_changed = (subdomains.status IS DISTINCT FROM excluded.status OR subdomains.cname IS DISTINCT FROM excluded.cname),
        vulnerable = $5;
    `
	_, err := db.Exec(query, subdomain, status, cname, hasIP, vulnerable)
	return err
}

// List of vulnerable nameservers (with wildcards)
var vulnerableNameservers = []string{
	`ns1\w*\.name\.com`, // Matches ns1 followed by any characters ending with .name.com
	`ns2\w*\.name\.com`,
	`ns3\w*\.name\.com`,
	`ns4\w*\.name\.com`,
	`ns-cloud-\w*\.googledomains\.com`, // Matches ns-cloud- followed by any characters ending with .googledomains.com
	`yns1\.yahoo\.com`,
	`yns2\.yahoo\.com`,
	`ns1\.reg\.ru`,
	`ns2\.reg\.ru`,
	`ns1\.mydomain\.com`,
	`ns2\.mydomain\.com`,
	`ns1\.linode\.com`,
	`ns2\.linode\.com`,
	`ns5\.he\.net`,
	`ns4\.he\.net`,
	`ns3\.he\.net`,
	`ns2\.he\.net`,
	`ns1\.he\.net`,
	`ns1\.dnsimple\.com`,
	`ns2\.dnsimple\.com`,
	`ns3\.dnsimple\.com`,
	`ns4\.dnsimple\.com`,
	`ns1\.digitalocean\.com`,
	`ns2\.digitalocean\.com`,
	`ns3\.digitalocean\.com`,
	`ns1\.000domains\.com`,
	`ns2\.000domains\.com`,
	`fwns1\.000domains\.com`,
	`fwns2\.000domains\.com`,
}

// MatchVulnerableNameserver checks if a nameserver matches any of the vulnerable patterns
func MatchVulnerableNameserver(nameserver string) bool {
	for _, pattern := range vulnerableNameservers {
		match, _ := regexp.MatchString(pattern, nameserver)
		if match {
			return true
		}
	}
	return false
}

// checkPotentialTakeover checks a subdomain for potential takeovers using CNAME, A record, and SOA checks
func checkPotentialTakeover(subdomain string) (string, string, bool, bool) {
	cleanSubdomain := stripProtocol(subdomain)

	var cname string
	var hasIP bool = false
	var vulnerable bool = false
	var status string

	// List of DNS resolvers to retry with
	resolvers := []string{"8.8.8.8:53", "1.1.1.1:53", "9.9.9.9:53"}

	// Retry the DNS query across multiple resolvers for CNAME
	for _, resolver := range resolvers {
		msg := new(dns.Msg)
		msg.SetQuestion(dns.Fqdn(cleanSubdomain), dns.TypeCNAME)
		in, err := dns.Exchange(msg, resolver)
		if err != nil {
			log.Printf("DNS query failed for %s on resolver %s: %v", cleanSubdomain, resolver, err)
			status = "SERVFAIL"
			continue // Try the next resolver
		}

		// Check if the domain returns a CNAME record
		if len(in.Answer) == 0 {
			// No CNAME found, now attempt A record resolution
			msgA := new(dns.Msg)
			msgA.SetQuestion(dns.Fqdn(cleanSubdomain), dns.TypeA)
			inA, err := dns.Exchange(msgA, resolver)
			if err == nil && len(inA.Answer) > 0 {
				for _, ans := range inA.Answer {
					if aRecord, ok := ans.(*dns.A); ok {
						hasIP = true
						status = "NOERROR" // A record found, so status is NOERROR
						log.Printf("A record found for %s: %v", cleanSubdomain, aRecord.A)
						return status, "", hasIP, false // Mark as not vulnerable since it's a valid A record
					}
				}
			} else if len(inA.Ns) > 0 {
				// If no A record is found but SOA exists, mark as SOA
				for _, ns := range inA.Ns {
					if soa, ok := ns.(*dns.SOA); ok {
						log.Printf("SOA record found for %s: %v", cleanSubdomain, soa)
						return "SOA", "", false, false // Marking as SOA, not vulnerable
					}
				}
			} else {
				log.Printf("No CNAME, A record, or SOA found for %s, marking as NXDOMAIN", cleanSubdomain)
				status = "NXDOMAIN" // If no CNAME, A record, or SOA is found, mark as NXDOMAIN
			}
		} else {
			// CNAME found, process it
			for _, answer := range in.Answer {
				if cnameRecord, ok := answer.(*dns.CNAME); ok {
					cname = cnameRecord.Target
					status = "NOERROR"
					log.Printf("CNAME found for %s: %s", cleanSubdomain, cname)
					break
				}
			}
		}

		// If a valid CNAME was found, no need to continue retrying with other resolvers
		if cname != "" {
			break
		}
	}

	// Retry logic: If all resolvers fail with SERVFAIL, mark as SERVFAIL
	if status == "SERVFAIL" {
		log.Printf("All resolvers returned SERVFAIL for %s", cleanSubdomain)
		// Check if the CNAME is a vulnerable service even though it returned SERVFAIL
		for service := range vulnerableServices {
			if strings.Contains(cname, service) {
				log.Printf("Subdomain %s \033[32mis vulnerable\033[0m (status: %s, CNAME: %s)", cleanSubdomain, status, cname)
				vulnerable = true
				return status, cname, hasIP, vulnerable // Mark vulnerable if SERVFAIL with a vulnerable CNAME
			}
		}
		// Check if any nameserver is vulnerable based on pattern matching
		if len(cname) > 0 && MatchVulnerableNameserver(cname) {
			log.Printf("Subdomain %s \033[32mis vulnerable\033[0m (status: %s, Nameserver: %s)", cleanSubdomain, status, cname)
			vulnerable = true
			return status, cname, hasIP, vulnerable
		}
		return status, cname, hasIP, false // Otherwise, just return SERVFAIL and not vulnerable
	}

	// Check if the domain points to a vulnerable service (for NXDOMAIN or NOERROR)
	log.Printf("Checking vulnerability for %s (status: %s, CNAME: %s)", cleanSubdomain, status, cname)
	for service := range vulnerableServices {
		if strings.Contains(cname, service) {
			// Vulnerable if CNAME points to a vulnerable service and has NXDOMAIN
			if status == "NXDOMAIN" {
				log.Printf("Subdomain %s \033[32mis vulnerable\033[0m (status: %s, CNAME: %s)", cleanSubdomain, status, cname)
				vulnerable = true
				break
			}
		}
	}

	// If nothing is found (no CNAME, A record, or SOA), mark as INVALID
	if cname == "" && status == "NXDOMAIN" {
		log.Printf("Marking %s as INVALID", cleanSubdomain)
		return "INVALID", "", false, false
	}

	// Log if no vulnerability was found
	if !vulnerable {
		log.Printf("Subdomain %s is \033[31mnot vulnerable\033[0m (status: %s)", cleanSubdomain, status)
	}

	return status, cname, hasIP, vulnerable
}

// stripProtocol removes any "http://" or "https://" from the domain
func stripProtocol(subdomain string) string {
	subdomain = strings.TrimPrefix(subdomain, "http://")
	subdomain = strings.TrimPrefix(subdomain, "https://")
	return subdomain
}

// executeCommand runs a command and handles errors
func executeCommand(cmd *exec.Cmd) {
	fmt.Printf("\033[33mExecuting command: %s\033[0m\n", strings.Join(cmd.Args, " "))
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		log.Fatalf("Command failed: %v", err)
	}
}

// Add getUserAgent function
func getUserAgent(program string) string {
	switch program {
	case "Bugcrowd":
		return "User-Agent:Bugcrowd:brainspiller"
	case "HackerOne":
		return "User-Agent:HackerOne:brainspiller"
	case "Intigriti":
		return "User-Agent:Intigriti:brainspiller"
	case "Synack":
		return "User-Agent:Synack:brainspiller"
	case "YesWeHack":
		return "User-Agent:YesWeHack:brainspiller"
	default:
		return ""
	}
}

func main() {
	// Database connection
	psqlInfo := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=disable",
		host, port, user, password, dbname)

	db, err := sql.Open("postgres", psqlInfo)
	if err != nil {
		log.Fatalf("Failed to connect to database: %v", err)
	}
	defer db.Close()

	err = db.Ping()
	if err != nil {
		log.Fatalf("Failed to ping database: %v", err)
	}
	log.Println("Connected to the database.")

	if len(os.Args) != 3 {
		fmt.Println("Usage: go run subdomain-exploiting.go <domain> <program>")
		fmt.Println("Programs: Bugcrowd, HackerOne, Intigriti, Synack, YesWeHack")
		os.Exit(1)
	}

	domain := os.Args[1]
	program := os.Args[2]
	outputBaseDir := "/home/brainspiller/Documents/hunt"
	toolDir := "/home/brainspiller/go/bin"
	crtShScript := "/opt/crt.sh/crt.sh"

	userAgent := getUserAgent(program)
	outputDir := filepath.Join(outputBaseDir, program, domain)

	fmt.Printf("Creating output directory: %s\n", outputDir)
	if err := os.MkdirAll(outputDir, os.ModePerm); err != nil {
		log.Fatalf("Failed to create output directory: %v", err)
	}

	fmt.Printf("Changing to output directory: %s\n", outputDir)
	if err := os.Chdir(outputDir); err != nil {
		log.Fatalf("Failed to change directory: %v", err)
	}

	targetsFile := filepath.Join(outputDir, "targets.txt")
	fmt.Printf("Writing targets to file: %s\n", targetsFile)
	if err := os.WriteFile(targetsFile, []byte(domain), 0644); err != nil {
		log.Fatalf("Failed to write to targets.txt: %v", err)
	}

	subfinderCmd := exec.Command(filepath.Join(toolDir, "subfinder"), "-dL", targetsFile, "-all", "--recursive", "-o", "Subs.txt")
	executeCommand(subfinderCmd)
	fmt.Println("\033[32mSubfinder completed\033[0m")

	crtshCmd := exec.Command("/usr/bin/bash", "-c", fmt.Sprintf("%s -d %s -o Subs02.txt", crtShScript, domain))
	executeCommand(crtshCmd)
	fmt.Println("\033[32mcrt.sh completed\033[0m")

	assetfinderCmd := exec.Command(filepath.Join(toolDir, "assetfinder"), "--subs-only", domain)
	assetfinderOutput, err := assetfinderCmd.Output()
	if err != nil {
		log.Fatalf("Command failed: %v", err)
	}
	if err := os.WriteFile("Subs03.txt", assetfinderOutput, 0644); err != nil {
		log.Fatalf("Failed to write to Subs03.txt: %v", err)
	}
	fmt.Println("\033[32mAssetfinder completed\033[0m")

	findomainCmd := exec.Command(filepath.Join(toolDir, "findomain"), "-t", domain, "-u", "Subs04.txt")
	executeCommand(findomainCmd)
	fmt.Println("\033[32mFindomain completed\033[0m")

	// Combine results into AllSubs.txt
	crtshOutputFile := fmt.Sprintf("output/domain.%s.txt", domain)
	anewCmd := exec.Command("/usr/bin/bash", "-c", fmt.Sprintf("cat Subs*.txt %s | anew AllSubs.txt", crtshOutputFile))
	executeCommand(anewCmd)
	fmt.Println("\033[32mAnew completed\033[0m")

	aliveSubsFile := filepath.Join(outputDir, "AliveSubs.txt")
	httpxCmd := exec.Command("/usr/bin/sh", "-c", fmt.Sprintf("cat AllSubs.txt | %s -H %q | tee %s", filepath.Join(toolDir, "httpx"), userAgent, aliveSubsFile))
	executeCommand(httpxCmd)
	fmt.Println("\033[32mHttpx completed\033[0m")

	//file, err := os.Open(aliveSubsFile) - old code - We now use the AllSubs text - so we dont miss -hmm. Were having trouble finding that site.
	file, err := os.Open(filepath.Join(outputDir, "AllSubs.txt"))
	if err != nil {
		log.Fatalf("Failed to open AllSubs.txt: %v", err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		subdomain := scanner.Text()

		// Check for potential takeovers
		status, cname, hasIP, vulnerable := checkPotentialTakeover(subdomain)

		// Insert or update the database entry
		err := insertOrUpdateSubdomain(db, subdomain, status, cname, hasIP, vulnerable)
		if err != nil {
			log.Printf("Failed to insert/update subdomain %s: %v", subdomain, err)
		}

		if vulnerable {
			message := fmt.Sprintf("Potential subdomain takeover detected: [https://%s](https://%s)\n**CNAME**: **%s**\n**Status**: %s", subdomain, subdomain, cname, status)
			if err := sendDiscordNotification(potentialTakeoverWebhook, message); err != nil {
				log.Printf("Failed to send Discord notification: %v", err)
			}

			if err := sendDiscordNotification(potentialTakeoverWebhook, message); err != nil {
				log.Printf("Failed to send Discord notification: %v", err)
			}
		}
	}

	if err := scanner.Err(); err != nil {
		log.Fatalf("Failed to read AllSubs.txt: %v", err)
	}

	fmt.Println("Subdomains have been updated in the database.")

	message := fmt.Sprintf("Bug bounty - **Subdomain-Exploiting** has completed for **%s** on **%s**. Check the database for results.", domain, program)
	if err := sendDiscordNotification(scanCompletionWebhook, message); err != nil {
		log.Fatalf("Failed to send Discord notification: %v", err)
	}

	fmt.Println("\033[33mSubdomain exploiting completed\033[0m")
}
