package main

import (
	"bufio"
	"bytes"
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	//Reporting "subdomain-exploiting/Reporting"
	utils "subdomain-exploiting/Utils"

	"github.com/joho/godotenv"
	_ "github.com/lib/pq" // PostgreSQL driver
	"github.com/miekg/dns"
)

// Vulnerable services for subdomain takeovers and their associated fingerprints
var vulnerableServices = map[string]string{
	"elasticbeanstalk.com": "NXDOMAIN",
	"s3.amazonaws.com":     "The specified bucket does not exist",
	"agilecrm.com":         "Sorry, this page is no longer available.",
	"airee.ru":             "Ошибка 402. Сервис Айри.рф не оплачен",
	"animaapp.io":          "The page you were looking for does not exist.",
	"bitbucket.io":         "Repository not found",
	"canny.io":             "Company Not Found There is no such company. Did you enter the right URL?",
	"cargo.site":           "404 Not Found",
	"digitalocean.com":     "Domain uses DO name servers with no records in DO.",
	"trydiscourse.com":     "NXDOMAIN",
	"furyns.com":           "404: This page could not be found.",
	"getresponse.com":      "With GetResponse Landing Pages, lead generation has never been easier",
	"ghost.io":             "Site unavailable\\.|Failed to resolve DNS path for this host",
	"github.io":            "There isn't a GitHub Pages site here.",
	"hatenablog.com":       "404 Blog is not found",
	"helpjuice.com":        "We could not find what you're looking for.",
	"helpscoutdocs.com":    "No settings were found for this company:",
	"helprace.com":         "HTTP_STATUS=301",
	"heroku.com":           "No such app",
	"youtrack.cloud":       "is not a registered InCloud YouTrack",
	"launchrock.com":       "HTTP_STATUS=500",
	"ngrok.io":             "Tunnel .*\\.ngrok.io not found",
	"pantheon.io":          "404 error unknown site!",
	"pingdom.com":          "Sorry, couldn't find the status page",
	"readme.io":            "The creators of this project are still working on making everything perfect!",
	"readthedocs.org":      "The link you have followed or the URL that you entered does not exist.",
	"short.io":             "Link does not exist",
	"52.16.160.97":         "This job board website is either expired or its domain name is invalid.",
	"strikinglydns.com":    "PAGE NOT FOUND.",
	"na-west1.surge.sh":    "project not found",
	"surveysparrow.com":    "Account not found.",
	"read.uberflip.com":    "The URL you've accessed does not provide a hub.",
	"uptimerobot.com":      "page not found",
	"wordpress.com":        "Do you want to register .*.wordpress.com?",
	"worksites.net":        "Hello! Sorry, but the website you’re looking for doesn’t exist.",

	// AWS-specific patterns for DNS subdomain takeovers
	`s3-website\.\w+-\w+-\d+\.amazonaws\.com`:  "The specified bucket does not exist",          // S3 static website
	`s3\.\w+-\w+-\d+\.amazonaws\.com`:          "The specified bucket does not exist",          // Regular S3 bucket
	`cloudfront\.net`:                          "403 ERROR The request could not be satisfied", // CloudFront distributions
	`elb\.amazonaws\.com`:                      "403 ERROR",                                    // Elastic Load Balancer
	`execute-api\.\w+-\w+-\d+\.amazonaws\.com`: "403 Forbidden",                                // API Gateway
	`lambda-url\.\w+-\w+-\d+\.amazonaws\.com`:  "403 Forbidden",                                // Lambda URL patterns

	// Added Azure Services (All check for NXDOMAIN)
	"cloudapp.net":            "NXDOMAIN",
	"cloudapp.azure.com":      "NXDOMAIN",
	"azurewebsites.net":       "NXDOMAIN",
	"blob.core.windows.net":   "NXDOMAIN",
	"azure-api.net":           "NXDOMAIN",
	"azurehdinsight.net":      "NXDOMAIN",
	"azureedge.net":           "NXDOMAIN",
	"azurecontainer.io":       "NXDOMAIN",
	"database.windows.net":    "NXDOMAIN",
	"azuredatalakestore.net":  "NXDOMAIN",
	"search.windows.net":      "NXDOMAIN",
	"azurecr.io":              "NXDOMAIN",
	"redis.cache.windows.net": "NXDOMAIN",
	"servicebus.windows.net":  "NXDOMAIN",
	"visualstudio.com":        "NXDOMAIN",
}

//Data base .env credentials - not hardcoded

func envdatabase() (*sql.DB, error) {
	// Define the file path for the .env file
	envFilePath := filepath.Join("/home", "brainspiller", "Documents", "hunt", "SubdomainExploiting", ".env")

	// Load the .env file
	err := godotenv.Load(envFilePath)
	if err != nil {
		log.Fatalf("Error loading .env file")
	}

	// Fetch credentials from environment variables
	host := os.Getenv("DB_HOST")
	portStr := os.Getenv("DB_PORT")
	user := os.Getenv("DB_USER")
	password := os.Getenv("DB_PASSWORD")
	dbname := os.Getenv("DB_NAME")

	port, _ := strconv.Atoi(portStr)

	psqlInfo := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=disable",
		host, port, user, password, dbname)

	db, err := sql.Open("postgres", psqlInfo)
	if err != nil {
		return nil, fmt.Errorf("error opening database: %v", err)
	}

	err = db.Ping()
	if err != nil {
		return nil, fmt.Errorf("error connecting to database: %v", err)
	}

	log.Println("Connected to the database.")
	return db, nil
}

// Helper function to send a notification to Discord
func sendDiscordNotification(webhookURL, message string) error {
	payload := map[string]string{"content": message}
	jsonData, err := json.Marshal(payload)
	if err != nil {
		return fmt.Errorf("failed to marshal payload: %v", err)
	}

	resp, err := http.Post(webhookURL, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return fmt.Errorf("failed to send POST request: %v", err)
	}
	defer resp.Body.Close()

	// Now using io.ReadAll to read response body instead of os.ReadFile
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read response body: %v", err)
	}

	if resp.StatusCode != http.StatusNoContent {
		return fmt.Errorf("unexpected response from Discord: %s", body)
	}

	return nil
}

// insertOrUpdateSubdomain inserts or updates a subdomain in the database
func insertOrUpdateSubdomain(db *sql.DB, subdomain, status, cname string, hasIP, vulnerable bool) error {
	query := `
    INSERT INTO subdomains (name, status, cname, has_ip, last_checked, status_changed, vulnerable)
    VALUES ($1, $2, $3, $4, NOW(), TRUE, $5)
    ON CONFLICT (name)
    DO UPDATE SET 
        status = $2, 
        cname = $3, 
        has_ip = $4, 
        last_checked = NOW(),
        status_changed = (subdomains.status IS DISTINCT FROM excluded.status OR subdomains.cname IS DISTINCT FROM excluded.cname),
        vulnerable = $5;
    `
	_, err := db.Exec(query, subdomain, status, cname, hasIP, vulnerable)
	return err
}

// List of vulnerable nameservers (with wildcards)
var vulnerableNameservers = []string{
	`ns1\w*\.name\.com`, // Matches ns1 followed by any characters ending with .name.com
	`ns2\w*\.name\.com`,
	`ns3\w*\.name\.com`,
	`ns4\w*\.name\.com`,
	`ns-cloud-\w*\.googledomains\.com`, // Matches ns-cloud- followed by any characters ending with .googledomains.com
	`yns1\.yahoo\.com`,
	`yns2\.yahoo\.com`,
	`ns1\.reg\.ru`,
	`ns2\.reg\.ru`,
	`ns1\.mydomain\.com`,
	`ns2\.mydomain\.com`,
	`ns1\.linode\.com`,
	`ns2\.linode\.com`,
	`ns5\.he\.net`,
	`ns4\.he\.net`,
	`ns3\.he\.net`,
	`ns2\.he\.net`,
	`ns1\.he\.net`,
	`ns1\.dnsimple\.com`,
	`ns2\.dnsimple\.com`,
	`ns3\.dnsimple\.com`,
	`ns4\.dnsimple\.com`,
	`ns1\.digitalocean\.com`,
	`ns2\.digitalocean\.com`,
	`ns3\.digitalocean\.com`,
	`ns1\.000domains\.com`,
	`ns2\.000domains\.com`,
	`fwns1\.000domains\.com`,
	`fwns2\.000domains\.com`,

	// AWS Route 53 nameserver patterns
	`ns-\d+\.awsdns-\d+\.co\.uk`, // Matches ns-<digits>.awsdns-<digits>.co.uk
	`ns-\d+\.awsdns-\d+\.org`,    // Matches ns-<digits>.awsdns-<digits>.org
	`ns-\d+\.awsdns-\d+\.net`,    // Matches ns-<digits>.awsdns-<digits>.net
	`ns-\d+\.awsdns-\d+\.com`,    // Matches ns-<digits>.awsdns-<digits>.com
}

// MatchVulnerableNameserver checks if a nameserver matches any of the vulnerable patterns
func MatchVulnerableNameserver(nameserver string) bool {
	for _, pattern := range vulnerableNameservers {
		match, _ := regexp.MatchString(pattern, nameserver)
		if match {
			return true
		}
	}
	return false
}

// checkPotentialTakeover checks a subdomain for potential takeovers using CNAME, A record, and SOA checks
func checkPotentialTakeover(subdomain string) (string,string, bool, bool, []string) {
    cleanSubdomain := stripProtocol(subdomain)

    var cname string
    var hasIP bool = false
    var vulnerable bool = false
    var status string
    var nsRecords []string // Stores NS records

    // List of DNS resolvers to retry with
    resolvers := []string{"8.8.8.8:53", "1.1.1.1:53", "9.9.9.9:53", "8.8.4.4:53"}

    // Retry the DNS query across multiple resolvers for CNAME
    for _, resolver := range resolvers {
        msg := new(dns.Msg)
        msg.SetQuestion(dns.Fqdn(cleanSubdomain), dns.TypeCNAME)
        in, err := dns.Exchange(msg, resolver)
        if err != nil {
            log.Printf("DNS query failed for %s on resolver %s: %v", cleanSubdomain, resolver, err)
            status = "SERVFAIL"
            continue // Try the next resolver
        }

        // Check if the domain returns a CNAME record
        if len(in.Answer) == 0 {
            // No CNAME found, now attempt A record resolution
            msgA := new(dns.Msg)
            msgA.SetQuestion(dns.Fqdn(cleanSubdomain), dns.TypeA)
            inA, err := dns.Exchange(msgA, resolver)
            if err == nil && len(inA.Answer) > 0 {
                for _, ans := range inA.Answer {
                    if aRecord, ok := ans.(*dns.A); ok {
                        hasIP = true
                        status = "NOERROR" // A record found, so status is NOERROR
                        log.Printf("A record found for %s: %v", cleanSubdomain, aRecord.A)
                        return status, "", hasIP, false, nil // Mark as not vulnerable since it's a valid A record
                    }
                }
            } else if len(inA.Ns) > 0 {
                // If no A record is found but SOA exists, mark as SOA
                for _, ns := range inA.Ns {
                    if soa, ok := ns.(*dns.SOA); ok {
                        log.Printf("SOA record found for %s: %v", cleanSubdomain, soa)
                        return "SOA", "", false, false, nil // Marking as SOA, not vulnerable
                    }
                }
            } else {
                log.Printf("No CNAME, A record, or SOA found for %s, marking as NXDOMAIN", cleanSubdomain)
                status = "NXDOMAIN" // If no CNAME, A record, or SOA is found, mark as NXDOMAIN
            }
        } else {
            // CNAME found, process it
            for _, answer := range in.Answer {
                if cnameRecord, ok := answer.(*dns.CNAME); ok {
                    cname = cnameRecord.Target
                    status = "NOERROR"
                    log.Printf("CNAME found for %s: %s", cleanSubdomain, cname)
                    break
                }
            }
        }

        // If a valid CNAME was found, no need to continue retrying with other resolvers
        if cname != "" {
            break
        }
    }

    // Retry logic: If all resolvers fail with SERVFAIL, mark as SERVFAIL
    if status == "SERVFAIL" {
        log.Printf("All resolvers returned SERVFAIL for %s", cleanSubdomain)

        // Attempt to get NS records if SERVFAIL detected
        nsRecords, _ = GetNSRecords(cleanSubdomain) // No need to handle error in this context

        // Check if the CNAME is a vulnerable service even though it returned SERVFAIL
        for service := range vulnerableServices {
            if strings.Contains(cname, service) {
                log.Printf("Subdomain %s is vulnerable (status: %s, CNAME: %s)", cleanSubdomain, status, cname)
                vulnerable = true
                return status, cname, hasIP, vulnerable, nsRecords // Mark vulnerable if SERVFAIL with a vulnerable CNAME
            }
        }

        // Check if any nameserver is vulnerable based on pattern matching
        if len(cname) > 0 && MatchVulnerableNameserver(cname) {
            log.Printf("Subdomain %s is vulnerable (status: %s, Nameserver: %s)", cleanSubdomain, status, cname)
            vulnerable = true
            return status, cname, hasIP, vulnerable, nsRecords
        }
        return status, cname, hasIP, false, nsRecords // Otherwise, return SERVFAIL and not vulnerable
    }

    // Check if the domain points to a vulnerable service (for NXDOMAIN or NOERROR)
    log.Printf("Checking vulnerability for %s (status: %s, CNAME: %s)", cleanSubdomain, status, cname)
    for service := range vulnerableServices {
        if strings.Contains(cname, service) {
            // Vulnerable if CNAME points to a vulnerable service and has NXDOMAIN
            if status == "NXDOMAIN" {
                log.Printf("Subdomain %s is vulnerable (status: %s, CNAME: %s)", cleanSubdomain, status, cname)
                vulnerable = true
                break
            }
        }
    }

    // If no records are found (status is NXDOMAIN or NOERROR) and no CNAME, mark as INVALID
    if cname == "" && (status == "NXDOMAIN" || status == "NOERROR") {
        log.Printf("Marking %s as INVALID", cleanSubdomain)
        return "INVALID", "", false, false, nil
    }

    // Log if no vulnerability was found
    if !vulnerable {
        log.Printf("Subdomain %s is not vulnerable (status: %s)", cleanSubdomain, status)
    }

    return status, cname, hasIP, vulnerable, nil
}

// GetNSRecords retrieves the nameservers (NS) for a given domain
func GetNSRecords(subdomain string) ([]string, error) {
    var nsRecords []string

    msg := new(dns.Msg)
    msg.SetQuestion(dns.Fqdn(subdomain), dns.TypeNS)

    resolvers := []string{"8.8.8.8:53", "1.1.1.1:53", "9.9.9.9:53", "8.8.4.4:53"}

    for _, resolver := range resolvers {
        in, err := dns.Exchange(msg, resolver)
        if err != nil {
            log.Printf("DNS NS query failed for %s on resolver %s: %v", subdomain, resolver, err)
            continue
        }

        // Extract NS records from the response
        for _, answer := range in.Answer {
            if nsRecord, ok := answer.(*dns.NS); ok {
                nsRecords = append(nsRecords, nsRecord.Ns)
            }
        }

        // If NS records are found, return them
        if len(nsRecords) > 0 {
            return nsRecords, nil
        }
    }

    if len(nsRecords) == 0 {
        return nil, fmt.Errorf("no NS records found for %s", subdomain)
    }

    return nsRecords, nil
}


// stripProtocol removes any "http://" or "https://" from the domain
func stripProtocol(subdomain string) string {
	subdomain = strings.TrimPrefix(subdomain, "http://")
	subdomain = strings.TrimPrefix(subdomain, "https://")
	return subdomain
}

// executeCommand runs a command and handles errors
func executeCommand(cmd *exec.Cmd) {
	fmt.Printf("\033[33mExecuting command: %s\033[0m\n", strings.Join(cmd.Args, " "))
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		log.Fatalf("Command failed: %v", err)
	}
}

// Add getUserAgent function
func getUserAgent(program string) string {
	switch program {
	case "Bugcrowd":
		return "User-Agent:Bugcrowd:brainspiller"
	case "HackerOne":
		return "User-Agent:HackerOne:brainspiller"
	case "Intigriti":
		return "User-Agent:Intigriti:brainspiller"
	case "Synack":
		return "User-Agent:Synack:brainspiller"
	case "YesWeHack":
		return "User-Agent:YesWeHack:brainspiller"
	default:
		return ""
	}
}

func main() {
	// Load environment variables from the .discordhooks.env file
	utils.LoadEnv("/home/brainspiller/Documents/hunt/.discordhooks.env")

	// Get the Discord webhook URLs from environment variables
	scanCompletionWebhook := utils.GetScanCompletionWebhook()
	//potentialTakeoverWebhook := utils.GetPotentialTakeoverWebhook()

	// Database connection
	// Call envdatabase() to load environment variables and establish a database connection
	db, err := envdatabase()
	if err != nil {
		log.Fatalf("Failed to connect to database: %v", err)
	}
	defer db.Close() // Always close the database connection when done

	if len(os.Args) != 3 {
		fmt.Println("Usage: go run subdomain-exploiting.go <domain> <program>")
		fmt.Println("Programs: Bugcrowd, HackerOne, Intigriti, Synack, YesWeHack")
		os.Exit(1)
	}

	domain := os.Args[1]
	program := os.Args[2]
	outputBaseDir := "/home/brainspiller/Documents/hunt"
	toolDir := "/home/brainspiller/go/bin"
	crtShScript := "/opt/crt.sh/crt.sh"

	userAgent := getUserAgent(program)
	outputDir := filepath.Join(outputBaseDir, program, domain)

	fmt.Printf("Creating output directory: %s\n", outputDir)
	if err := os.MkdirAll(outputDir, os.ModePerm); err != nil {
		log.Fatalf("Failed to create output directory: %v", err)
	}

	fmt.Printf("Changing to output directory: %s\n", outputDir)
	if err := os.Chdir(outputDir); err != nil {
		log.Fatalf("Failed to change directory: %v", err)
	}

	targetsFile := filepath.Join(outputDir, "targets.txt")
	fmt.Printf("Writing targets to file: %s\n", targetsFile)
	if err := os.WriteFile(targetsFile, []byte(domain), 0644); err != nil {
		log.Fatalf("Failed to write to targets.txt: %v", err)
	}

	subfinderCmd := exec.Command(filepath.Join(toolDir, "subfinder"), "-dL", targetsFile, "-all", "--recursive", "-o", "Subs.txt")
	executeCommand(subfinderCmd)
	fmt.Println("\033[32mSubfinder completed\033[0m")

	crtshCmd := exec.Command("/usr/bin/bash", "-c", fmt.Sprintf("%s -d %s -o Subs02.txt", crtShScript, domain))
	executeCommand(crtshCmd)
	fmt.Println("\033[32mcrt.sh completed\033[0m")

	assetfinderCmd := exec.Command(filepath.Join(toolDir, "assetfinder"), "--subs-only", domain)
	assetfinderOutput, err := assetfinderCmd.Output()
	if err != nil {
		log.Fatalf("Command failed: %v", err)
	}
	if err := os.WriteFile("Subs03.txt", assetfinderOutput, 0644); err != nil {
		log.Fatalf("Failed to write to Subs03.txt: %v", err)
	}
	fmt.Println("\033[32mAssetfinder completed\033[0m")

	findomainCmd := exec.Command(filepath.Join(toolDir, "findomain"), "-t", domain, "-u", "Subs04.txt")
	executeCommand(findomainCmd)
	fmt.Println("\033[32mFindomain completed\033[0m")

	// Combine results into AllSubs.txt
	crtshOutputFile := fmt.Sprintf("output/domain.%s.txt", domain)
	anewCmd := exec.Command("/usr/bin/bash", "-c", fmt.Sprintf("cat Subs*.txt %s | anew AllSubs.txt", crtshOutputFile))
	executeCommand(anewCmd)
	fmt.Println("\033[32mAnew completed\033[0m")

	aliveSubsFile := filepath.Join(outputDir, "AliveSubs.txt")
	httpxCmd := exec.Command("/usr/bin/sh", "-c", fmt.Sprintf("cat AllSubs.txt | %s -H %q | tee %s", filepath.Join(toolDir, "httpx"), userAgent, aliveSubsFile))
	executeCommand(httpxCmd)
	fmt.Println("\033[32mHttpx completed\033[0m")

	// Open the file that contains all subdomains (AllSubs.txt)
file, err := os.Open(filepath.Join(outputDir, "AllSubs.txt"))
if err != nil {
    log.Fatalf("Failed to open AllSubs.txt: %v", err)
}
defer file.Close()

scanner := bufio.NewScanner(file)
for scanner.Scan() {
    subdomain := scanner.Text()

    // Check for potential takeovers
    status, cname, hasIP, vulnerable, _ := checkPotentialTakeover(subdomain)

    // Insert or update the database entry
    err := insertOrUpdateSubdomain(db, subdomain, status, cname, hasIP, vulnerable)
    if err != nil {
        log.Printf("Failed to insert/update subdomain %s: %v", subdomain, err)
    }

    // Generate and send notification if the subdomain is vulnerable
    //if vulnerable {
        // Generate the report data
    //    reportData := Reporting.ReportData{
    //        Subdomain:  subdomain,
    //        RootDomain: domain,
    //        WhatWasIt:  cname,          // CNAME or a description of what was vulnerable
    //        Account:    "AzureAccount", // You can set this dynamically or manually
    //        Mitigation: "CNAME",        // You can set this dynamically or manually
    //    }

        // If there are NS records (from SERVFAIL cases), append them to the report
    //    if len(nsRecords) > 0 {
    //        reportData.WhatWasIt += fmt.Sprintf("\n\nNameservers: %v", strings.Join(nsRecords, ", "))
    //    }

        // Generate the report (this step likely formats the report for the webhook)
    //    report, err := Reporting.GenerateReport(reportData)
    //    if err != nil {
    //        log.Printf("Failed to generate report for %s: %v", subdomain, err)
    //    } else {
            // Send the generated report to Discord
    //        if err := sendDiscordNotification(potentialTakeoverWebhook, report); err != nil {
    //            log.Printf("Failed to send Discord report notification: %v", err)
    //        }
    //    }
   // }
}

// Handle any scanner errors
if err := scanner.Err(); err != nil {
    log.Fatalf("Failed to read AllSubs.txt: %v", err)
}

fmt.Println("Subdomains have been updated in the database.")

// Send a scan completion message to Discord
message := fmt.Sprintf("Bug bounty - **Subdomain-Exploiting** has completed for **%s** on **%s**. Check the database for results.", domain, program)
if err := sendDiscordNotification(scanCompletionWebhook, message); err != nil {
    log.Fatalf("Failed to send Discord notification: %v", err)
}

fmt.Println("Subdomain exploiting completed")
}