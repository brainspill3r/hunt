package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	//    "sync"
	"syscall"
	"time"
)

// remindToStartDocker checks if Docker is running and reminds the user to start it if not
func remindToStartDocker() {
	cmd := exec.Command("docker", "info")
	err := cmd.Run()
	if err != nil {
		fmt.Println("Have you remembered to start Docker? If not, cancel the script and run 'sudo dockerd' in another terminal.")
	}
}

// validateProgram checks if the provided program is valid
func validateProgram(program string) bool {
	validPrograms := []string{"Bugcrowd", "HackerOne", "Intigriti", "Synack", "YesWeHack"}
	for _, validProgram := range validPrograms {
		if program == validProgram {
			return true
		}
	}
	return false
}

// getUserAgent returns the user-agent based on the program
func getUserAgent(program string) string {
	switch program {
	case "Bugcrowd":
		return "User-Agent:Bugcrowd:brainspiller"
	case "HackerOne":
		return "User-Agent:HackerOne:brainspiller"
	case "Intigriti":
		return "User-Agent:Intigriti:brainspiller"
	case "Synack":
		return "User-Agent:Synack:brainspiller"
	case "YesWeHack":
		return "User-Agent:YesWeHack:brainspiller"
	default:
		return ""
	}
}

// executeCommand runs a command and handles errors, capturing its output
func executeCommand(cmd *exec.Cmd) {
	fmt.Printf("\033[33mExecuting command: %s\033[0m\n", strings.Join(cmd.Args, " ")) // Orange color for executing commands
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		log.Fatalf("Command failed: %v", err)
	}
}

// executeCommandWithOutput runs a command and captures its output
func executeCommandWithOutput(cmd *exec.Cmd) (string, error) {
	fmt.Printf("\033[33mExecuting command: %s\033[0m\n", strings.Join(cmd.Args, " ")) // Orange color for executing commands
	var out bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &out
	err := cmd.Run()
	return out.String(), err
}

// showProgress shows progress while a long-running command is executed
func showProgress(pid int) {
	delay := 15 * time.Minute
	for {
		if process, err := os.FindProcess(pid); err == nil {
			if err := process.Signal(syscall.Signal(0)); err == nil {
				fmt.Println("Nuclei scan in progress, please wait...")
				time.Sleep(delay)
			} else {
				break
			}
		} else {
			break
		}
	}
}

// runNucleiScan runs nuclei scan with progress indicator
func runNucleiScan(description, outputFile string, nucleiCmd []string) {
	fmt.Printf("Running nuclei %s...\n", description)
	cmd := exec.Command(nucleiCmd[0], nucleiCmd[1:]...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Start(); err != nil {
		log.Fatalf("Failed to start nuclei scan: %v", err)
	}

	go showProgress(cmd.Process.Pid)

	if err := cmd.Wait(); err != nil {
		log.Fatalf("Nuclei scan failed: %v", err)
	}

	fmt.Printf("Nuclei %s completed. Results saved to %s.\n", description, outputFile)
}

// sendDiscordNotification sends a notification to a Discord webhook
func sendDiscordNotification(webhookURL, message string) error {
	payload := map[string]string{"content": message}
	jsonData, err := json.Marshal(payload)
	if err != nil {
		return fmt.Errorf("failed to marshal payload: %v", err)
	}

	resp, err := http.Post(webhookURL, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return fmt.Errorf("failed to send POST request: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusNoContent {
		body, _ := ioutil.ReadAll(resp.Body)
		return fmt.Errorf("unexpected response from Discord: %s", body)
	}

	return nil
}

// checkAndAddValidJson checks and adds valid JSON files to the array
func checkAndAddValidJson(file string, validFiles *[]string) {
	if info, err := os.Stat(file); err == nil && info.Size() > 0 {
		if cmd := exec.Command("jq", "-e", ".", file); cmd.Run() == nil {
			*validFiles = append(*validFiles, file)
		} else {
			fmt.Printf("Skipping invalid or empty file: %s\n", file)
		}
	}
}

func main() {
	remindToStartDocker()

	if len(os.Args) != 3 {
		fmt.Println("Usage: go run nuclei-scanner.go <domain> <program>")
		fmt.Println("Programs: Bugcrowd, HackerOne, Intigriti, Synack, YesWeHack")
		os.Exit(1)
	}

	domain := os.Args[1]
	program := os.Args[2]
	outputBaseDir := "/home/brainspiller/Documents/hunt"
	toolDir := "/home/brainspiller/go/bin"
	discordWebhookURL := "https://discord.com/api/webhooks/1261250175549313054/v1UixRHt6jJBnQChb1I-YdFE-j8wUN5LiAK3Uy9TovjSpkDe5MFixrM9DpafhiAphsEf"

	if !validateProgram(program) {
		fmt.Println("Invalid program. Choose from: Bugcrowd, HackerOne, Intigriti, Synack, YesWeHack")
		os.Exit(1)
	}

	userAgent := getUserAgent(program)
	outputDir := filepath.Join(outputBaseDir, program, domain)

	fmt.Printf("Creating output directory: %s\n", outputDir)
	if err := os.MkdirAll(outputDir, os.ModePerm); err != nil {
		log.Fatalf("Failed to create output directory: %v", err)
	}

	fmt.Printf("Changing to output directory: %s\n", outputDir)
	if err := os.Chdir(outputDir); err != nil {
		log.Fatalf("Failed to change directory: %v", err)
	}

	aliveSubsFile := filepath.Join(outputDir, "AliveSubs.txt")
	urlsFile := filepath.Join(outputDir, "urls.txt")
	jsFile := filepath.Join(outputDir, "js.txt")
	lfiFile := filepath.Join(outputDir, "lfi.txt")

	if _, err := os.Stat(aliveSubsFile); os.IsNotExist(err) {
		log.Fatalf("AliveSubs.txt does not exist in the specified directory")
	}

	nucleiTemplatesDir := "/opt/nuclei-templates/http"

	// Run nuclei scans sequentially
	runNucleiScan("Takeovers scan on AliveSubs.txt", "nucleitakeovers.json", []string{filepath.Join(toolDir, "nuclei"), "-t", filepath.Join(nucleiTemplatesDir, "takeovers"), "-l", aliveSubsFile, "-H", userAgent, "-o", "nucleitakeovers.json", "--rl", "50", "-no-mhe"})
	runNucleiScan("Vulnerabilities scan on AliveSubs.txt", "nucleivulns.json", []string{filepath.Join(toolDir, "nuclei"), "-t", filepath.Join(nucleiTemplatesDir, "vulnerabilities"), "-l", aliveSubsFile, "-H", userAgent, "-o", "nucleivulns.json", "--rl", "50", "-no-mhe"})
	runNucleiScan("CVEs scan on AliveSubs.txt", "nucleicves.json", []string{filepath.Join(toolDir, "nuclei"), "-t", filepath.Join(nucleiTemplatesDir, "cves"), "-l", aliveSubsFile, "-H", userAgent, "-o", "nucleicves.json", "--rl", "50", "-no-mhe"})
	runNucleiScan("Exposures scan on AliveSubs.txt", "nucleiexposures.json", []string{filepath.Join(toolDir, "nuclei"), "-t", filepath.Join(nucleiTemplatesDir, "exposures"), "-l", aliveSubsFile, "-H", userAgent, "-o", "nucleiexposures.json", "--rl", "50", "-no-mhe"})
	runNucleiScan("Fuzzing scan on urls.txt", "nucleifuzzing.json", []string{filepath.Join(toolDir, "nuclei"), "-t", filepath.Join(nucleiTemplatesDir, "fuzzing"), "-l", urlsFile, "-H", userAgent, "-o", "nucleifuzzing.json", "--rl", "50", "-no-mhe"})
	runNucleiScan("Exposures scan on js.txt", "jsBugs.json", []string{filepath.Join(toolDir, "nuclei"), "-t", filepath.Join(nucleiTemplatesDir, "exposures"), "-l", jsFile, "-H", userAgent, "-o", "jsBugs.json", "--rl", "50", "-no-mhe"})
	runNucleiScan("LFI scan on lfi.txt", "lfiFindings.json", []string{filepath.Join(toolDir, "nuclei"), "-tags", "lfi", "-l", lfiFile, "-H", userAgent, "-o", "lfiFindings.json", "--rl", "50", "-no-mhe"})

	// Check and add valid JSON files
	var validFiles []string
	checkAndAddValidJson("nucleitakeovers.json", &validFiles)
	checkAndAddValidJson("nucleivulns.json", &validFiles)
	checkAndAddValidJson("nucleicves.json", &validFiles)
	checkAndAddValidJson("nucleiexposures.json", &validFiles)
	checkAndAddValidJson("nucleifuzzing.json", &validFiles)
	checkAndAddValidJson("jsBugs.json", &validFiles)
	checkAndAddValidJson("lfiFindings.json", &validFiles)

	// Combine valid JSON files into potentialvulns.json
	if len(validFiles) > 0 {
		jqCmd := exec.Command("jq", append([]string{". | select(.info.severity == \"low\" or .info.severity == \"medium\" or .info.severity == \"high\" or .info.severity == \"critical\")"}, validFiles...)...)
		jqOutput, err := executeCommandWithOutput(jqCmd)
		if err != nil {
			log.Fatalf("jq command failed: %v", err)
		}
		if err := os.WriteFile("potentialvulns.json", []byte(jqOutput), 0644); err != nil {
			log.Fatalf("Failed to write to potentialvulns.json: %v", err)
		}
	} else {
		fmt.Println("No valid JSON files to process.")
		if err := os.WriteFile("potentialvulns.json", []byte(""), 0644); err != nil {
			log.Fatalf("Failed to create empty potentialvulns.json: %v", err)
		}
	}

	// Convert JSON to text for potentialvulns.txt
	jqCmd := exec.Command("jq", "-r", ". | \"\\(.name): \\(.severity)\\n\\(.description)\\n\"", "potentialvulns.json")
	jqOutput, err := executeCommandWithOutput(jqCmd)
	if err != nil {
		log.Fatalf("jq command failed: %v", err)
	}
	if err := os.WriteFile("potentialvulns.txt", []byte(jqOutput), 0644); err != nil {
		log.Fatalf("Failed to write to potentialvulns.txt: %v", err)
	}

	fmt.Println("\033[31mNuclei scans completed\033[0m")

	message := fmt.Sprintf("Bug bounty - **Nuclei Scanner** has completed for **%s** on **%s**. Check your **potentialvulns.json** and **potentialvulns.txt** to see the results.", domain, program)
	if err := sendDiscordNotification(discordWebhookURL, message); err != nil {
		log.Fatalf("Failed to send Discord notification: %v", err)
	}
}
